#include "pathfinding/utils.hpp"

#include <algorithm>
#include <cstdint>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

namespace pathfinding_utils
{

bool operator==(const Node & lhs, const Node & rhs) { return lhs.x == rhs.x && lhs.y == rhs.y; }

bool operator!=(const Node & lhs, const Node & rhs) { return !(lhs == rhs); }

// The logic in the operator< function is negated because it is used for a priority queue in the A*
// algorithm. In the A* algorithm, the node with the lowest f value (the sum of the cost to reach
// the node and the estimated cost to the goal) is considered the highest priority. Therefore, the
// nodes are sorted in descending order of f values, which is achieved by using the greater-than
// operator (>) instead of the less-than operator (<).
bool operator<(const Node & lhs, const Node & rhs) { return lhs.f > rhs.f; }

OccupancyGrid::OccupancyGrid(const std::string filename, const uint8_t free_threshold)
{
  GetGridFromPGM(filename);
  ThresholdValues(free_threshold);
  std::cout << "Map has been successfully loaded. Size of the map: " << width_ << "x" << height_
            << std::endl;
}

OccupancyGrid::OccupancyGrid(
  std::vector<uint8_t> pixels, const unsigned width, const unsigned height,
  const unsigned max_value)
: pixels_(std::move(pixels)), width_(width), height_(height), max_value_(max_value)
{
  ValidateHeader();
  ValidateSize();
}

void OccupancyGrid::SaveAsPGM(const std::string filename) const
{
  if (pixels_.size() != width_ * height_) {
    throw std::runtime_error(
      "PGM file is broken. Map size does not match the number of pixel data");
  }

  std::string filename_with_ext = EnsurePGMExtension(filename);
  std::ofstream file(filename_with_ext);

  if (!file.is_open()) {
    throw std::runtime_error("Unable to open the file.");
  }

  file << "P5\n";
  file << "# Generated by task_1\n";
  file << width_ << " " << height_ << "\n";
  file << max_value_ << "\n";

  for (auto & pixel : pixels_) {
    // Invert the pixel value. In .pgm format, 0 represents black and 255 represents white, while in
    // the OccupancyGrid class, 0 (associated with white color) represents free due to the
    // definitions of the free and occupied thresholds.
    uint8_t inverted_pixel = 255 - pixel;
    file.write(reinterpret_cast<const char *>(&inverted_pixel), sizeof(inverted_pixel));
  }

  file.close();

  std::cout << "Map has been successfully saved to: " << filename_with_ext << std::endl;
}

bool OccupancyGrid::IsOccupied(int x, int y) const
{
  if (x < 0 || x >= width_ || y < 0 || y >= height_) {
    throw std::out_of_range("Pixel coordinates out of range");
  }
  return pixels_[y * width_ + x] != CellOccupancyLevel::FREE;
}

void OccupancyGrid::DrawPath(const std::vector<Node> & path, const uint8_t color)
{
  for (const auto & node : path) {
    (*this)(node.x, node.y) = color;
  }
}

void OccupancyGrid::GetGridFromPGM(const std::string & filename)
{
  std::ifstream file(filename, std::ios::binary);

  if (!file.is_open()) {
    throw std::runtime_error("Unable to open the PGM file: " + filename);
  }

  std::string magic_number;
  std::getline(file, magic_number);
  if (magic_number != "P5") {
    throw std::runtime_error("This is not a P5 format PGM file: " + filename);
  }

  // Skip comment line
  std::getline(file, magic_number);

  file >> width_ >> height_;
  file >> max_value_;
  file.ignore();  // Ignore the newline character after max. value

  ValidateHeader();

  std::vector<uint8_t> pixels(width_ * height_);
  for (auto & pixel : pixels) {
    uint8_t pgm_data;
    file.read(reinterpret_cast<char *>(&pgm_data), sizeof(pgm_data));

    // Invert the pixel value. In .pgm format, 0 represents black and 255 represents white, while in
    // the OccupancyGrid class, 0 (associated with white color) represents free due to the
    // definitions of the free and occupied thresholds.
    pixel = 255 - pgm_data;
  }

  file.close();

  pixels_ = std::move(pixels);
  ValidateSize();
}

void OccupancyGrid::ThresholdValues(const uint8_t free_threshold)
{
  std::transform(pixels_.begin(), pixels_.end(), pixels_.begin(), [free_threshold](uint8_t pixel) {
    return pixel <= free_threshold ? CellOccupancyLevel::FREE : CellOccupancyLevel::OCCUPIED;
  });
}

void OccupancyGrid::ValidateHeader() const
{
  if (width_ <= 0 || height_ <= 0) {
    throw std::runtime_error("Invalid PGM header");
  }

  if (max_value_ > 255) {
    throw std::runtime_error("Max value exceeds 255 (unsupported)");
  }
}

void OccupancyGrid::ValidateSize() const
{
  if (pixels_.size() != width_ * height_) {
    throw std::runtime_error(
      "Map import from file failed. Map size does not match the number of pixel data.");
  }
}

std::string OccupancyGrid::EnsurePGMExtension(const std::string & filename) const
{
  if (filename.size() >= 4 && filename.compare(filename.size() - 4, 4, ".pgm") == 0) {
    return filename;
  } else {
    return filename + ".pgm";
  }
}

}  // namespace pathfinding_utils
