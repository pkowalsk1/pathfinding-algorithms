#include "pathfinding/binary_map.hpp"

#include <algorithm>
#include <cstdint>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

namespace pathfinding_utils
{

BinaryMap::BinaryMap(const std::string filename, const uint8_t free_threshold)
{
  GetMapFromPGM(filename);
  ThresholdMapValues(free_threshold);
}

BinaryMap::BinaryMap(
  std::vector<uint8_t> pixels, const unsigned width, const unsigned height,
  const unsigned max_value)
: pixels_(std::move(pixels)), width_(width), height_(height), max_value_(max_value)
{
  ValidateMapHeader();
  ValidateMapSize();
}

void BinaryMap::SaveAsPGM(const std::string filename) const
{
  if (pixels_.size() != width_ * height_) {
    throw std::runtime_error(
      "PGM file is broken. Map size does not match the number of pixel data");
  }

  std::string filename_with_ext = EnsurePGMExtension(filename);
  std::ofstream file(filename_with_ext);

  if (!file.is_open()) {
    throw std::runtime_error("Unable to open the file.");
  }

  file << "P5\n";
  file << "# Generated by task_1\n";
  file << width_ << " " << height_ << "\n";
  file << max_value_ << "\n";

  for (auto & pixel : pixels_) {
    file << std::hex << pixel;
  }

  file.close();
}

bool BinaryMap::IsOccupied(int x, int y) const
{
  if (x < 0 || x >= width_ || y < 0 || y >= height_) {
    throw std::out_of_range("Pixel coordinates out of range");
  }
  return pixels_[y * width_ + x] != CellOccupancyLevel::FREE;
}

void BinaryMap::GetMapFromPGM(const std::string & filename)
{
  std::ifstream file(filename, std::ios::binary);

  if (!file.is_open()) {
    throw std::runtime_error("Unable to open the PGM file: " + filename);
  }

  std::string magic_number;
  std::getline(file, magic_number);
  if (magic_number != "P5") {
    throw std::runtime_error("This is not a P5 format PGM file: " + filename);
  }

  // Skip comment line
  std::getline(file, magic_number);

  file >> width_ >> height_;
  file >> max_value_;
  file.ignore();  // Ignore the newline character after max. value

  ValidateMapHeader();

  std::vector<uint8_t> pixels(width_ * height_);
  for (auto & pixel : pixels) {
    char pgm_data;
    file.read(&pgm_data, 1);
    pixel = static_cast<uint8_t>(pgm_data);
  }

  file.close();

  pixels_ = std::move(pixels);
  ValidateMapSize();
}

void BinaryMap::ThresholdMapValues(const uint8_t free_threshold)
{
  std::transform(pixels_.begin(), pixels_.end(), pixels_.begin(), [free_threshold](uint8_t pixel) {
    return pixel <= free_threshold ? CellOccupancyLevel::FREE : CellOccupancyLevel::OCCUPIED;
  });
}

void BinaryMap::ValidateMapHeader() const
{
  if (width_ <= 0 || height_ <= 0) {
    throw std::runtime_error("Invalid PGM header");
  }

  if (max_value_ > 255) {
    throw std::runtime_error("Max value exceeds 255 (unsupported)");
  }
}

void BinaryMap::ValidateMapSize() const
{
  if (pixels_.size() != width_ * height_) {
    throw std::runtime_error(
      "Map import from file failed. Map size does not match the number of pixel data.");
  }
}

std::string BinaryMap::EnsurePGMExtension(const std::string & filename) const
{
  if (filename.size() >= 4 && filename.compare(filename.size() - 4, 4, ".pgm") == 0) {
    return filename;
  } else {
    return filename + ".pgm";
  }
}

}  // namespace pathfinding_utils
